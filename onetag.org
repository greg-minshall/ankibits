* ONETAG: (anki menu item)
** what we want to do

it turns out that Anki opens files in a way that won't allow a
pipeline (as far as i can see), so the file itself needs to have the
tags in it.  or, maybe /dev/fdN could be used?

want a function that, given an argument, will ensure that 1) the
current deck has only cards with TAG; 2) all cards in Anki with TAG
are in that deck.

so, first, find all cards *not* in the current deck with TAG.  then,
move all those cards from their previous deck to the current deck.

XXX should we check we're not moving *too* many cards?

then, search the current deck and find all cards that do *not* have
the the designated tag.  delete all those cards.

XXX same, should we check we're not deleting too many cards?

remove the menu item (or, at least, the pre-canned tag)

after all this, *delete* the tags from all cards in the current
deck.

*** ANKI-IMPORT: (shell command)
usage: run the import operation, which cons up TAG, and adds it to
all the cards in the deck, then imports the cards into the named
deck: ./anki-import turkish-2015 turkish-2015.html after the import,
prime a menu item in Anki (with a shortcut, hopefully), that will
cause onetag to run with the correct tag.

one function: given a file name and a deck name, import the contents
of that file into that deck.  need to have it tell how many fields
it will find (maybe separate function for that?).

one function: given a search expression (such as "deck:current
tag:fubar"), execute the search, and then execute a "move" to a
designated deck (which must already exist).

one function: given a search expression, execute the search and
print out the resulting cards.

one function: print the names of the existing decks.

one function: remove a given tag from a given (all?) deck(s?).

** X11 anki

to get anki to work, need to run ./tools/build-ui.sh.  for *that*,
needed something from Qt designer, which required installing a bunch
of Qt.  then, to actually run it, needed to extend path, which i did
by
#+BEGIN_EXAMPLE
bash
PATH=/sw/lib/qt4-mac/lib/python2.7/bin/:$PATH
./tools/build_ui.sh 
#+END_EXAMPLE
then, needed to copy all the files to ~/usr/lib/python/anki/ again
(i.e., *after* running ./tools/build-ui.sh).

cool.  now have an x11 version of anki ("% ./runanki").

** some bugs maybe in dae's code/documentation
*** [[http://ankisrs.net/docs/addons.html][add-on documentation]] bugs

+ in "Import a text file into the collection", should
#+BEGIN_QUOTE
deck['mid'] = m['id']
#+END_QUOTE
possibly be
#+BEGIN_QUOTE
deck['mod'] = m['mod']
#+END_QUOTE
?

+ also, i run this code, and my cards get added to the "Default" deck
  (rather than to the one i looked up using col.decks.id), or (it
  appears) whichever deck was most recently "selected".  here's (more
  or less) DAE's example:
#+BEGIN_SRC python :session ps :var TEXT_FILE_PATH="/Users/minshall/src/mine/ankiplugins/test.html" :var COLLECTION_FILE_PATH=anki2 :var DECK_NAME=deckname
  from anki import Collection
  from anki.importing import TextImporter
  file = TEXT_FILE_PATH
  collection = COLLECTION_FILE_PATH
  deckName = DECK_NAME
  col = Collection(collection)
  ti = TextImporter(col, file)
  # get note type for deck (could be a parameter)
  m = col.models.byName("Basic")
  # select deck
  did = col.decks.byName(deckname)
  # make sure we are importing to desired deck
  col.decks.select(did)
  if did != ti.model['did']:
     ti.model['did'] = did
     col.models.save(ti.model)
  # import into the collection
  ti.initMapping()
  ti.run()
  col.close()
#+END_SRC
** random documentation

nice [[http://www.norvig.com/python-lisp.html][comparison]] of Python and Lisp.

it appears that the fnotes themselves maybe contain information
about the destination deck.  or, at least, that when importing, one
of the rows in addNew is supposed to contain the deck name?

we could import, then use the _ids in the TextImporter object, or
just the tags we used, to move the new cards into the deck we want.
(assuming we figure *that* out! :)

** code
*** parameters

i'm not sure how to get scalar parameters into variables.  the
following works, but is maybe not ideal.

#+name: parameters
| /Users/minshall/Documents/Anki/test/collection.anki2 |
| decktest                                             |
| /Users/minshall/src/mine/ankiplugins/test.html       |

#+name: anki2
#+BEGIN_SRC python :var a=parameters[0,0] :results results raw
a
#+END_SRC

#+RESULTS[90f772dc0313b916f2f89b493f51aef5d5351cf8]: anki2
/Users/minshall/Documents/Anki/test/collection.anki2

#+name: deckname
#+BEGIN_SRC python :var a=parameters[1,0] :results results raw
a
#+END_SRC

#+RESULTS[fe3bb60a68b6853fa7d7b2e7bb50abe431ff3935]: deckname
decktest

#+name: imfile
#+BEGIN_SRC python :var a=parameters[2,0] :results results raw
a
#+END_SRC

#+RESULTS[fc56904fc33ce7b967cb09b25e451de24614ee04]: imfile
/Users/minshall/src/mine/ankiplugins/test.html

one might want to say "#+name: foo\nbar\n", but then ":var a=foo"
produces a value in a of "bar\n", i.e., with a trailing newline.

also, one might want to say ":cache yes", but *then*, the value passed
is "nil" (in the case where the cache entry is valid).

*** utilities
**** collection_guard

this allows us to open an Anki collection and ensure that the
collection is closed "no matter what" happens.  (this does *not*
include some extraordinary event, such as a core dump.)  this comes
from http://effbot.org/zone/python-with-statement.htm

#+name: collection_guard
#+BEGIN_SRC python :results silent
  class collection_guard:
      def __init__(self, ankipath):
          self.ankipath = ankipath
      def __enter__(self):
          self.col = Collection(self.ankipath)
          return self
      def __exit__(self, type, value, traceback):
          # the protocol is, do a commit() *before* exiting
          self.undo()
          if self.col is not None:
              self.col.close()
              self.col = None
          return False
      def undo(self):            # we're unhappy, so undo() our progress
          if self.col is not None:
              # XXX what's the difference btw col.undo() and .rollback()?
              self.col.rollback()
      def commit(self):
          if self.col is not None:
              self.col.save()
#+END_SRC

**** unescape

the following html unescape() function is from [[http://stackoverflow.com/a/7088472][this post]] on
stackoverflow.

but, some [[http://stackoverflow.com/questions/24395155/python-unencode-unicode-html-hexadecimal][problems]] when printing out notes with non-ASCII characters
in them.
#+BEGIN_EXAMPLE
EncodeError: 'ascii' codec can't encode character u'\xd6' in position 21: ordinal not in range(128)
#+END_EXAMPLE
this [[http://stackoverflow.com/a/7892892][environment variable]] approach works.  but isn't optimal.  when
writing to the terminal, sys.stdout.encoding == 'UTF-8', but when
writing to a file or pipe, it is set to 'None', which i guess (this
always makes my head hurt) causes the error message.  would like a way
to generally change the encoding of standard out.

[[http://stackoverflow.com/a/2738005][this]] appears to do the trick.

#+name: unescape
#+BEGIN_SRC python :results silent
  try:
      from html import unescape  # python 3.4+
  except ImportError:
      try:
          from html.parser import HTMLParser  # python 3.x (<3.4)
      except ImportError:
          from HTMLParser import HTMLParser  # python 2.x
      unescape = HTMLParser().unescape
#+END_SRC

**** recipe577058 (yes/no dialog)

#+name: recipe577058
#+BEGIN_SRC python :session ps :results silent
  # from http://code.activestate.com/recipes/577058/

  def query_yes_no(question, default="yes"):
      import sys
      """Ask a yes/no question via raw_input() and return their answer.

      "question" is a string that is presented to the user.
      "default" is the presumed answer if the user just hits <Enter>.
      It must be "yes" (the default), "no" or None (meaning
      an answer is required of the user).

      The "answer" return value is one of "yes" or "no".
      """
      valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
               "no":"no",     "n":"no"}
      if default == None:
          prompt = " [y/n] "
      elif default == "yes":
          prompt = " [Y/n] "
      elif default == "no":
          prompt = " [y/N] "
      else:
          raise ValueError("invalid default answer: '%s'" % default)
      # for some reason, a blank line here generates an error
      while 1:
          sys.stdout.write(question + prompt)
          # handle C-c at this point
          choice = raw_input().lower()
          if default is not None and choice == '':
              return default
          elif choice in valid.keys():
              return valid[choice]
          else:
              sys.stdout.write("Please respond with 'yes' or 'no' "\
                               "(or 'y' or 'n').\n")
#+END_SRC

**** myparse, myargs, myargsdeck

#+name: myparse
#+BEGIN_SRC python :results silent :noweb yes
  import argparse

  <<collection_guard>>
  <<consankipath>>

  def myparse(parser, argv=None, deckmustexist=True):
      """parse the arguments; set up ankipath and, optionally, check if deck exists"""
      import argparse
      import codecs
      import sys

      global debugging, verbosity

      args = parser.parse_args(argv)
      debugging = args.debugging
      verbosity = args.verbosity

      if debugging > 1:
          print args

      ankipath = consankipath(args.path, args.user)
      if debugging:
          print ankipath

      # dir(): http://stackoverflow.com/a/191029
      if ('deckname' in dir(args)) & deckmustexist:
          with collection_guard(ankipath) as cg:
              if cg.col.decks.byName(args.deckname) == None:
                  import sys
                  print "error: deckname %s does not exist" % args.deckname
                  sys.exit(3)

      # sigh.  we *also* make sure stdout uses utf-8 encoding
      # (to avoid the errors mentioned above at unescape())
      sys.stdout = codecs.getwriter('utf-8')(sys.stdout)

      return [args, ankipath]
#+END_SRC


#+name: myargs
#+BEGIN_SRC python :results silent :noweb yes
  def myargs():
      import argparse
      parser = argparse.ArgumentParser(add_help=False)
      parser.add_argument("-p", "--path", action="store",
                          default="~/Documents/Anki", metavar="pathname",
                          help="pathname to directory holding Anki collections")
      parser.add_argument("-u", "--user", action="store",
                          default="User 1", metavar="username",
                          help="Anki username of collection")
      parser.add_argument("--debugging", action="count", default=0,
                          help="increase level of (debugging) verbosity")
      parser.add_argument("-v", "--verbosity", action="count",
                          default=0,
                          help="increase level of verbosity")
      return parser

  # for convenience
  <<myparse>>
#+END_SRC


#+name: myargsdeck
#+BEGIN_SRC python :results silent :noweb yes
  <<myargs>>

  def myargsdeck():
      parser = argparse.ArgumentParser(parents=[myargs()], add_help=False)
      parser.add_argument("-d", "--deck", action="store", dest='deckname',
                          default='Default',
                          help="name of deck in Anki user's collection")
      return parser
#+END_SRC

#+name: consankipath
#+BEGIN_SRC python :results silent
  def consankipath(path, user):
      import os

      unexpandedpath = ''.join([path, '/', user, '/', 'collection.anki2'])
      # https://docs.python.org/2/library/os.path.html#os.path.expanduser
      ankipath = os.path.expanduser(os.path.expandvars(unexpandedpath))
      if debugging:
          print ankipath
      return ankipath
#+END_SRC

#+name: abspath
#+BEGIN_SRC python :results silent
  def abspath(path):
      import os

      return os.path.abspath(os.path.expanduser(os.path.expandvars(path)))
#+END_SRC

**** pager

[[http://stackoverflow.com/questions/89228/calling-an-external-command-in-python#89243][invoking a sub-process from python]]; but, for us, we need to use [[https://docs.python.org/2/library/subprocess.html][popen]].

#+name: pager
#+BEGIN_SRC python :noweb yes
  def pager(text):
      """display text on the terminal (via less)"""
      import os
      import shlex
      import subprocess

      # figure out pager to use
      # http://stackoverflow.com/a/4907053
      try:
          pager = os.environ['PAGER']
      except KeyError:
          # does "less" exist?
      args = shlex.split("less")
      p = subprocess.Popen(args, stdin=subprocess.PIPE)
      p.communicate(text)
      p.stdin.close()
      p.wait()
#+END_SRC

*** ankidecks [--user username] [--path pathname]

list the decks in the collection.  the optional argument /username/
argument specifies the "username" of the Anki collection.

the optional /pathname/ (typically something like ~/Documents/Anki/)
is the pathname where Anki collections are stored.


#+name: decks
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  def pdecks(col):
      for i, val in enumerate(col.decks.allNames()):
          print val
#+END_SRC


#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankidecks :shebang "#!/usr/bin/env python"
  import argparse

  <<collection_guard>>
  <<decks>>
  <<myargs>>

  def main():
      # scope rules (LEGB): http://stackoverflow.com/a/292502
      parser = argparse.ArgumentParser(description=
                                       "list the decks in an Anki collection",
                                       parents=[myargs()])
      args, ankipath = myparse(parser)

      with collection_guard(ankipath) as cg:
          pdecks(cg.col)
          cg.commit()

  if __name__ == "__main__":
      main()
#+END_SRC

*** ankicards [--user username] [--path pathname]

list out the notes from a given deck (the name of which is required).

#+name: cards
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  <<unescape>>

  def fcard(col, id):
      card = col.getCard(id)
      if debugging:
          print card
      card = col.getCard(id)
      note = card.note()
      values = note.values()
      # http://stackoverflow.com/a/60211
      type = { 0: "new",
               1: "learning",
               2: "due" }[card.type]
      # only print queue if different from card type (above)
      queue = { -3: "/sched-buried",
                -2: "/user-buried",
                -1: "/suspended",
                0: "",
                1: "",
                2: "" }[card.queue]
      due = card.due
      return "%s%s/%s: %s" % (type, queue, due, unescape("%s\t%s" % (values[0], values[1])))

  def pcards(col, deckname):
      ids = col.findCards("deck:%s" % deckname)
      if debugging:
          print ids
      for i, id in enumerate(ids):
          print fcard(col, id)
#+END_SRC

#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankicards :shebang "#!/usr/bin/env python"
  <<collection_guard>>
  <<myargsdeck>>
  <<cards>>

  def main():
      parser = argparse.ArgumentParser(parents=[myargsdeck()],
                  description="list the notes in one deck in an Anki collection")
      args, ankipath = myparse(parser)

      with collection_guard(ankipath) as cg:
          pcards(cg.col, args.deckname)
          cg.commit()

  if __name__ == "__main__":
      main()
#+END_SRC

*** ankinotes [--user username] [--path pathname] [{-d|--deck} deckname]

list out the notes from a given deck (the name of which is required).

#+name: notes
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  <<unescape>>
  
  def pnotes(col, deckname):
      ids = col.findNotes("deck:%s" % deckname)
      if debugging:
          print ids
      for i, id in enumerate(ids):
          note = col.getNote(id)
          values = note.values()
          print unescape("%s\t%s" % (values[0], values[1]))
#+END_SRC

#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankinotes :shebang "#!/usr/bin/env python"
  <<collection_guard>>
  <<myargsdeck>>
  <<notes>>

  def main():
      parser = argparse.ArgumentParser(parents=[myargsdeck()],
                  description="list the notes in one deck in an Anki collection")
      args, ankipath = myparse(parser)

      with collection_guard(ankipath) as cg:
          pnotes(cg.col, args.deckname)
          cg.commit()

  if __name__ == "__main__":
      main()
#+END_SRC

*** ankitags [{-u|--user} username] [{-p|--path} pathname] [{-d|--deck} deckname]

list the tags that exist in a given deck, along with the number of
notes with each tag.

#+name: tags
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  def ptags(col, deckname):
      ids = col.findNotes("deck:%s" % deckname)
      if debugging:
          print ids
      # https://docs.python.org/2/library/stdtypes.html#dict
      tags = dict()
      for i, id in enumerate(ids):
          note = col.getNote(id)
          if debugging:
              print note.stringTags()
          for s in note.stringTags().split():
              if debugging:
                  print s
              # "s not in tags": http://stackoverflow.com/a/18300596
              if s not in tags:
                  tags[s] = 1
              else:
                  tags[s] += 1
      for t in iter(tags):
          print t, tags[t]
#+END_SRC

#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankitags :shebang "#!/usr/bin/env python"
  <<collection_guard>>
  <<myargsdeck>>
  <<tags>>

  def main():
      parser = argparse.ArgumentParser(parents=[myargsdeck()],
                  description="list the notes in one deck in an Anki collection")
      args, ankipath = myparse(parser)

      with collection_guard(ankipath) as cg:
          ptags(cg.col, args.deckname)
          cg.commit()

  if __name__ == "__main__":
      main()
#+END_SRC

*** ankisearch [{-p|--path} pathname] [{-u|--user} username] [{-d|--deck} deckname] query

search a given deck
#+name: search
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  <<unescape>>

  # XXX here (and elsewhere) check that deck exists
  # XXX graceful error message if user, database file doesn't exist
  def psearch(col, deckname, query):
      ids = []
      ids = col.findNotes("".join(["deck:", deckname, " ", query]))
      if debugging:
          print ids
      for i, id in enumerate(ids):
          note = col.getNote(id)
          values = note.values()
          print unescape("%s\t%s" % (values[0], values[1]))
#+END_SRC

#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankisearch :shebang "#!/usr/bin/env python"
  import sys

  <<collection_guard>>
  <<myargsdeck>>
  <<search>>

  def main():
      parser = argparse.ArgumentParser(parents=[myargsdeck()],
                      description="search the notes in one deck in an Anki collection")
      parser.add_argument("query", nargs=argparse.REMAINDER, action="store",
                          metavar="query",
                          help="query terms for search [e.g., 'tag:foo aspirin']")
      args, ankipath = myparse(parser)
      # "not args.query": http://stackoverflow.com/a/53522
      if ('query' not in args) | (not args.query):
          print "required 'query' term missing"
          parser.print_usage()
          sys.exit()

      with collection_guard(ankipath) as cg:
          psearch(cg.col, args.deckname, " ".join(args.query))
          cg.commit()

  if __name__ == "__main__":
      main()
#+END_SRC

*** ankiimport


#+name: user_interface
#+BEGIN_SRC python :noweb yes
  <<recipe577058>>

  def str2list(expected):
      """given a string representation of a list (of strings), make a list"""

      if expected:
          import re
          # make sure this looks good
          if re.match('\A\[[\w,]+\]\Z', expected):
              list = re.split('[\[\],]', expected)[1:-1]
              if debugging:
                  print "str2list(%s) returns %s" % (expected, list)
              return list
      return expected             # i.e., None



  # two functions: one that shows the mapping, allows one to proceed or
  # cancel (returns True or False); a second shows the results of the
  # import, allows one to accept or abort (returns True or False)

  # XXX allow user to specify expected mapping, abort (with message) if
  # different; don't query if same
  def checkmapping(ti, expected):
      """check the mapping (of note fields to card contents)

  if the user specified an expected mapping, check that, aborting (with
  an error message) if it doesn't match.  if no expected mapping was
  specified, display the mapping to the user, giving him/her the
  opportunity to cancel the import

      """
      if expected:
          mapping = []            # build up the actual mapping
          for num in range(len(ti.mapping)):
              if ti.mapping[num] == '_tags':
                  mapping = mapping + ['tags']
              elif ti.mapping[num]:
                  mapping = mapping + [ti.mapping[num].lower()]
              else:
                  mapping = mapping + ["ignored"]
          if mapping != expected: # if it doesn't match the expected mapping
              print "expected mapping (%s) not equal to computed (%s)" % \
                  (expected, mapping)
              abort()             # abort
      else:
          # from showMapping in aqt/importing.py
          for num in range(len(ti.mapping)):
              intro = "Field %d of file is:" % (num+1)
              if ti.mapping[num] == "_tags":
                  where = "mapped to Tags"
              elif ti.mapping[num]:
                  where = "mapped to %s" % ti.mapping[num]
              else:
                  where = "<ignored>"
              print "%s%s" % (intro, where)
          if query_yes_no("proceed with import?", default=None) == 'no':
              abort()
#+END_SRC


#+name: import
#+BEGIN_SRC python :noweb yes :tangle ankiimport :shebang "#!/usr/bin/env python"
  from anki import Collection
  from anki.importing import TextImporter

  <<abspath>>
  <<cards>>
  <<collection_guard>>
  <<myargsdeck>>
  <<unescape>>
  <<user_interface>>

  def abort(rc=3):
      import sys
      sys.exit(rc)

  # the official ternary operator
  # http://stackoverflow.com/a/394814
  # is too ugly
  def plurality(n, singular, plural):
      if abs(n) == 1:
          return singular
      else:
          return plural

  def logcards(col, why, prefix, ids):
      """send a list of cards (given by IDS) to the log; WHY is text explaining why"""
      if logfile:
          # http://stackoverflow.com/q/1987626
          print >> logfile, why
          for id in ids:
              print >> logfile, "%s%s" % (prefix, fcard(col, id))

  # XXX XXX XXX
  # tags with time, etc., on them are maybe useful for debugging,
  # but they consume lots of resources (as they cause Anki to say "well,
  # the entire deck has changed, and therefore upload/download the
  # entire deck).  ditto for first adding tags to a deck that had no
  # tags, then deleting all the tags: Anki still considers the entire
  # deck to have changed, consuming lots of bandwidth.
  #
  # one solution would be to name the tag '"deck-%s" % deckname', and
  # *leave* the tag in the deck.  seems messy, though, having those tags
  # lying around.
  def constag(deckname):
      # https://docs.python.org/2/library/time.html
      import time
      secs = int(time.time())
      tag = "deck-%s-%s" % (deckname, secs)
      if debugging:
          print "tag %s" % tag
      return tag

  def removetag(col, tag):
      """remove all instances of a given tag from an Anki collection"""
      # (above) https://www.python.org/dev/peps/pep-0257/
      ids = []
      ids = col.findNotes("tag:%s" % tag)
      if debugging:
          print "ids of notes with tag %s: %s" % (tag, ids)
      for i, id in enumerate(ids):
          note = col.getNote(id)
          if debugging > 2:
              print "%s %s//%s" % (id, note, note.tags)
          note.delTag(tag)
          note.flush()
          if debugging > 2:
              print "%s %s//%s" % (id, note, note.tags)

  def superset(col, deckname, tag):
      """make sure all cards with tag TAG are in Anki deck DECKNAME"""
      did = col.decks.byName(deckname)['id']
      ids = []
      ids = col.findCards("-deck:%s tag:%s" % (deckname, tag))
      if ids:
          if debugging:
              print "superset ids: %s" % ids
          n = len(ids)
          print "will move %s %s into deck %s" % \
              (n, plurality(len(ids),"card", "cards"), deckname)
          # XXX allow user to see what cards will be moved
          if query_yes_no("proceed with import?", default=None) == 'no':
              abort()
          logcards(col, "cards moved to deck %s" % deckname, "  ", ids)
          col.decks.setDeck(ids, did)

  def subset(col, deckname, tag):
      """make sure only cards with tag TAG are in Anki deck DECKNAME"""
      # XXX just deletes the cards; nicer might be to stash them somewhere
      ids = []
      ids = col.findCards("deck:%s -tag:%s" % (deckname, tag))
      if ids:
          if debugging:
              print "subset ids: %s" % ids
          n = len(ids)
          print "will delete %s %s from deck %s" % \
              (n, plurality(len(ids),"card", "cards"), deckname)
          # XXX allow user to see what cards will be deleted
          if query_yes_no("proceed with import?", default=None) == 'no':
              abort()
          logcards(col, "cards deleted from deck %s" % deckname, "  ", ids)
          # not sure about notes=True, but it makes sense for how we use it
          col.remCards(ids, notes=True)

  # get foreign notes: these aren't (yet) real Anki notes, just a
  # represenation that has been read in.
  def getfnotes(ti):
      # now, get the notes
      fnotes = ti.foreignNotes()
      return fnotes

  def addtag(ti, fnotes, tag):
      for i, fn in enumerate(fnotes):
          fn.tags.append(tag)

  def add2col(col, deckname, ti, fnotes):
      # XXX should we remember previously selected deck (and reselect it
      # when we're done here)?
      did = col.decks.byName(deckname)['id']
      if debugging:
          print "did %s" % did
      if did != ti.model['did']:
          ti.model['did'] = did
          col.models.save(ti.model)
      col.decks.select(did)
      ti.importNotes(fnotes)

  def doimport(col, deckname, ifilepath, mapping, dosubset, dosuperset):
      tag = constag(deckname)     # just run once!
      ti = TextImporter(col, ifilepath)
      ti.allowHTML = True
      ti.initMapping()
      checkmapping(ti, mapping)    # this may abort
      # first, get anki read in the notes (to an intermediate form)
      fnotes = getfnotes(ti)
      # next, add our tag to the notes (if we need it)
      if dosuperset | dosubset:
          addtag(ti, fnotes, tag)
      # now, add these notes to the designated deck
      add2col(col, deckname, ti, fnotes)
      if ti.log:
          # XXX don't print out all those lines; summarize (print
          # out first 3 lines), give option for paging through
          # everything (though, --logfilter helps)
          for txt in ti.log:
              if not logfilterpattern.search(txt):
                  utxt = unescape(txt)
                  print utxt
                  if logfile:
                      print >> logfile, utxt
      del ti                      # no longer to be used
      if dosuperset:
          # now, move any notes from any *other* decks with this tag to this deck
          superset(col, deckname, tag)
      if dosubset:
          # now, delete any notes in deck that do *not* have this tag
          subset(col, deckname, tag)
      # now, delete this tag from these cards (no other cards should have this tag)
      if dosuperset | dosubset:
          removetag(col, tag)
      # done!

  # http://ankisrs.net/docs/addons.html#the-database
  def main():
      import codecs
      import re
      import time

      global args, logfilterpattern, logfile

      parser = argparse.ArgumentParser(parents=[myargsdeck()],
                  description="import an HTML file into a deck in an Anki collection")
      parser.add_argument("-R", "--superset", action="store_true", default=False,
                          help="ensure the Anki deck is a supeRset of the input file")
      parser.add_argument("-B", "--subset", action="store_true", default=False,
                          help="ensure the Anki deck is a suBset of the input file")
      parser.add_argument("-m", "--mapping", action='store', default=None,
                          help="expected mapping of fields, e.g., '[front,back,tag]'")
      parser.add_argument("--logfilter", action='store',
                          default="First field matched",
                          help="regular expression of messages to *not* write to log")
      parser.add_argument("-l", "--logfile", type=argparse.FileType('a'), default=None,
                          help="file in which to log actions during import (appended)")
      parser.add_argument("inputfile", type=str)

      args, ankipath = myparse(parser)

      if args.logfile:
          logfile = codecs.getwriter('utf-8')(args.logfile)
          print >> logfile, "import started %s" % time.strftime("%x %X")
          print >> logfile, "arguments: %s" % args

      # https://wiki.python.org/moin/HandlingExceptions
      try:
          logfilterpattern = re.compile(args.logfilter)
      except:
          print "invalid regular expression in \"--logfilter %s\"" % args.logfilter
          abort()

      ifilepath = abspath(args.inputfile)
      with collection_guard(ankipath) as cg:
          doimport(cg.col, args.deckname, ifilepath, str2list(args.mapping),
                   dosubset=args.subset, dosuperset=args.superset)
          cg.commit()

  if __name__ == "__main__":
      main()

#+END_SRC
