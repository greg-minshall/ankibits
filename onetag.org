* ONETAG: (anki menu item)

** what we want to do

it turns out that Anki opens files in a way that won't allow a
pipeline (as far as i can see), so the file itself needs to have the
tags in it.  or, maybe /dev/fdN could be used?

want a function that, given an argument, will ensure that 1) the
current deck has only cards with TAG; 2) all cards in Anki with TAG
are in that deck.

so, first, find all cards *not* in the current deck with TAG.  then,
move all those cards from their previous deck to the current deck.

XXX should we check we're not moving *too* many cards?

then, search the current deck and find all cards that do *not* have
the the designated tag.  delete all those cards.

XXX same, should we check we're not deleting too many cards?

remove the menu item (or, at least, the pre-canned tag)

after all this, *delete* the tags from all cards in the current
deck.

*** ANKI-IMPORT: (shell command)
usage: run the import operation, which cons up TAG, and adds it to
all the cards in the deck, then imports the cards into the named
deck: ./anki-import turkish-2015 turkish-2015.html after the import,
prime a menu item in Anki (with a shortcut, hopefully), that will
cause onetag to run with the correct tag.

one function: given a file name and a deck name, import the contents
of that file into that deck.  need to have it tell how many fields
it will find (maybe separate function for that?).

one function: given a search expression (such as "deck:current
tag:fubar"), execute the search, and then execute a "move" to a
designated deck (which must already exist).

one function: given a search expression, execute the search and
print out the resulting cards.

one function: print the names of the existing decks.

one function: remove a given tag from a given (all?) deck(s?).


** X11 anki

to get anki to work, need to run ./tools/build-ui.sh.  for *that*,
needed something from Qt designer, which required installing a bunch
of Qt.  then, to actually run it, needed to extend path, which i did
by
#+BEGIN_EXAMPLE
bash
PATH=/sw/lib/qt4-mac/lib/python2.7/bin/:$PATH
./tools/build_ui.sh 
#+END_EXAMPLE
then, needed to copy all the files to ~/usr/lib/python/anki/ again
(i.e., *after* running ./tools/build-ui.sh).

cool.  now have an x11 version of anki ("% ./runanki").

** some bugs maybe in dae's code/documentation

** random documentation

nice [[http://www.norvig.com/python-lisp.html][comparison]] of Python and Lisp.

*** [[http://ankisrs.net/docs/addons.html][add-on documentation]] bugs

+ in "Import a text file into the collection", should
#+BEGIN_QUOTE
deck['mid'] = m['id']
#+END_QUOTE
possibly be
#+BEGIN_QUOTE
deck['mod'] = m['mod']
#+END_QUOTE
?

+ also, i run this code, and my cards get added to the "Default" deck
  (rather than to the one i looked up using col.decks.id), or (it
  appears) whichever deck was most recently "selected".  here's (more
  or less) DAE's example:
#+BEGIN_SRC python :session ps :var TEXT_FILE_PATH="/Users/minshall/src/mine/ankiplugins/test.html" :var COLLECTION_FILE_PATH=anki2 :var DECK_NAME=deckname
  from anki import Collection
  from anki.importing import TextImporter
  file = TEXT_FILE_PATH
  collection = COLLECTION_FILE_PATH
  deckName = DECK_NAME
  col = Collection(collection)
  ti = TextImporter(col, file)
  # get note type for deck (could be a parameter)
  m = col.models.byName("Basic")
  # select deck
  did = col.decks.id(deckName)
  # make sure we are importing to desired deck
  col.decks.select(did)
  if did != ti.model['did']:
     ti.model['did'] = did
     col.models.save(ti.model)
  # import into the collection
  ti.initMapping()
  ti.run()
  col.close()
#+END_SRC

#+RESULTS:

  it appears that the fnotes themselves maybe contain information
  about the destination deck.  or, at least, that when importing, one
  of the rows in addNew is supposed to contain the deck name?

  we could import, then use the _ids in the TextImporter object, or
  just the tags we used, to move the new cards into the deck we want.
  (assuming we figure *that* out! :)

** some code

*** parameters

i'm not sure how to get scalar parameters into variables.  the
following works, but is maybe not ideal.

#+name: parameters
| /Users/minshall/Documents/Anki/test/collection.anki2 |
| decktest                                             |
| /Users/minshall/src/mine/ankiplugins/test.html       |

#+name: anki2
#+BEGIN_SRC python :var a=parameters[0,0] :results results raw
a
#+END_SRC

#+RESULTS[90f772dc0313b916f2f89b493f51aef5d5351cf8]: anki2
/Users/minshall/Documents/Anki/test/collection.anki2

#+name: deckname
#+BEGIN_SRC python :var a=parameters[1,0] :results results raw
a
#+END_SRC

#+RESULTS[fe3bb60a68b6853fa7d7b2e7bb50abe431ff3935]: deckname
decktest

#+name: imfile
#+BEGIN_SRC python :var a=parameters[2,0] :results results raw
a
#+END_SRC

#+RESULTS[fc56904fc33ce7b967cb09b25e451de24614ee04]: imfile
/Users/minshall/src/mine/ankiplugins/test.html

one might want to say "#+name: foo\nbar\n", but then ":var a=foo"
produces a value in a of "bar\n", i.e., with a trailing newline.

also, one might want to say ":cache yes", but *then*, the value passed
is "nil" (in the case where the cache entry is valid).


*** code

**** collection_guard

this allows us to open an Anki collection and ensure that the
collection is closed "no matter what" happens.  (this does *not*
include some extraordinary event, such as a core dump.)  this comes
from http://effbot.org/zone/python-with-statement.htm

#+name: collection_guard
#+BEGIN_SRC python :results silent
  class collection_guard:
      def __init__(self, ankipath):
          self.ankipath = ankipath;
      def __enter__(self):
          self.col = Collection(self.ankipath);
          return self;
      def __exit__(self, type, value, traceback):
          if self.col is not None:
              self.col.close();
              self.col = None
          return False
      def abort(self):            # we're unhappy, so *don't* close
          if self.col is not None:
              self.col = None
      def close(self):
          self.__exit__(None, None, None)
#+END_SRC

**** ankidecks [--user username] [--path pathname]

list the decks in the collection.  the optional argument /username/
argument specifies the "username" of the Anki collection.

the optional /pathname/ (typically something like ~/Documents/Anki/)
is the pathname where Anki collections are stored.


#+name: decks
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  <<collection_guard>>

  def pdecks(col):
      for i, val in enumerate(col.decks.allNames()):
          print val

  def pdecksrun(ankipath):
      with collection_guard(ankipath) as cg:
          pdecks(cg.col)
#+END_SRC


#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankidecks.py
  <<decks>>

  import sys, os, getopt

  def usage():
      print "usage: FOO [{-h|--help}] [{-u|--user} username] [{-p|--path} pathname]"
      sys.exit(2)

  def main():
      global verbose
      sarglist= 'hp:u:v'
      larglist = ['help', 'path=', 'user=', 'verbose']
      # lots from https://docs.python.org/2/library/getopt.html
      try:
          opts, args = getopt.getopt(sys.argv[1:], sarglist, larglist)
      except getopt.GetoptError as err:
          # print help information and exit:
          print str(err) # will print something like "option -a not recognized"
          usage()
          sys.exit(2)
      path = '~/Documents/Anki' # default
      user = 'User 1'           # default
      verbose = False
      for o, a in opts:
          if o in ['-h', '--help']:
              usage()
              # NOTREACHED
          elif o in ['-u', '--user']:
              user = a
          elif o in ['p', '--path']:
              path=a
          elif o in ["v", "--verbose"]:
              verbose = True
          else:
              print "unhandled option"
              usage()

      # the above line intentionally left blank
      unexpandedpath = ''.join([path, '/', user, '/', 'collection.anki2'])
      ankipath = os.path.expanduser(os.path.expandvars(unexpandedpath))
      if verbose:
          print ankipath
      pdecksrun(ankipath)

  if __name__ == "__main__":
      main()
#+END_SRC

**** ankinotes [--user username] [--path pathname] {-d|--deck} deckname

list out the notes from a given deck (the name of which is required).


#+name: notes
#+BEGIN_SRC python :results silent :noweb yes
  from anki import Collection

  <<collection_guard>>

  def pnotes(col, deckname):
      ids = col.findNotes("deck:%s" % deckname)
      if verbose:
          print ids;
      for i, id in enumerate(ids):
          note = col.getNote(id)
          values = note.values();
          print "%s\t%s" % (values[0], values[1])

  def pnotesrun(ankipath, deckname):
      with collection_guard(ankipath) as cg:
          pnotes(cg.col, deckname)
#+END_SRC

#+RESULTS: notes

#+BEGIN_SRC python :results output :session ps :noweb yes :tangle ankinotes.py
  <<notes>>

  import sys, os, getopt

  def usage():
      print "usage: FOO [{-h|--help}] [{-u|--user} username] [{-p|--path} pathname] [{-d|--deck} deckname]"
      sys.exit(2)

  def main():
      global verbose
      sarglist= 'd:hp:u:v'
      larglist = ['deck=', 'help', 'path=', 'user=', 'verbose']
      # from example code at https://docs.python.org/2/library/getopt.html
      try:
          opts, args = getopt.getopt(sys.argv[1:], sarglist, larglist)
      except getopt.GetoptError as err:
          # print help information and exit:
          print str(err) # will print something like "option -a not recognized"
          usage()
          # NOTREACHED
      path = '~/Documents/Anki' # default
      user = 'User 1'           # default
      verbose = False
      deckname = 'Default'
      for o, a in opts:
          if o in ['-d', '--deck']:
              deckname = a
          elif o in ['-h', '--help']:
              usage()
              # NOTREACHED
          elif o in ['-u', '--user']:
              user = a
          elif o in ['p', '--path']:
              path=a
          elif o in ['v', '--verbose']:
              verbose = True
          else:
              print "unhandled option"
              usage()

      # the above line intentionally left blank
      unexpandedpath = ''.join([path, '/', user, '/', 'collection.anki2'])
      ankipath = os.path.expanduser(os.path.expandvars(unexpandedpath))
      if verbose:
          print ankipath, deckname
      pnotesrun(ankipath, deckname);

  if __name__ == "__main__":
      main()
#+END_SRC

#+RESULTS:


#+name: tags
#+BEGIN_SRC python :results output :var anki=anki2 deckname=deckname :session ps
  from anki import Collection
  with collection_guard(ankipath) as cg:
      ids = cg.col.findCards("deck:%s" % deckname)
#+END_SRC

#+RESULTS: tags


#+name: recipe577058
#+BEGIN_SRC python :session ps :results silent
  # from http://code.activestate.com/recipes/577058/

  def query_yes_no(question, default="yes"):
      import sys
      """Ask a yes/no question via raw_input() and return their answer.

      "question" is a string that is presented to the user.
      "default" is the presumed answer if the user just hits <Enter>.
      It must be "yes" (the default), "no" or None (meaning
      an answer is required of the user).

      The "answer" return value is one of "yes" or "no".
      """
      valid = {"yes":"yes",   "y":"yes",  "ye":"yes",
               "no":"no",     "n":"no"}
      if default == None:
          prompt = " [y/n] "
      elif default == "yes":
          prompt = " [Y/n] "
      elif default == "no":
          prompt = " [y/N] "
      else:
          raise ValueError("invalid default answer: '%s'" % default)
      # for some reason, a blank line here generates an error
      while 1:
          sys.stdout.write(question + prompt)
          choice = raw_input().lower()
          if default is not None and choice == '':
              return default
          elif choice in valid.keys():
              return valid[choice]
          else:
              sys.stdout.write("Please respond with 'yes' or 'no' "\
                               "(or 'y' or 'n').\n")
#+END_SRC

#+name: user_interface
#+BEGIN_SRC python :noweb yes
  <<recipe577058>>

  # two functions: one that shows the mapping, allows one to proceed or
  # cancel (returns True or False); a second shows the results of the
  # import, allows one to accept or abort (returns True or False)

  def showMapping(ti):
      """show the mapping (of note fields to card contents) to the user, giving him/her the opportunity to cancel the import"""
      # from showMapping in aqt/importing.py
      for num in range(len(ti.mapping)):
          intro = "Field %d of file is:" % (num+1)
          if ti.mapping[num] == "_tags":
              where = "mapped to Tags"
          elif ti.mapping[num]:
              where = "mapped to %s" % ti.mapping[num]
          else:
              where = "<ignored>"
          print "%s%s" % (intro, where)
      return query_yes_no("proceed with import?", default=None) == 'yes'
#+END_SRC

#+BEGIN_SRC python :noweb yes
  <<collection_guard>>
  <<user_interface>>
#+END_SRC

#+RESULTS:
: None

#+name: import
#+BEGIN_SRC python :noweb yes
  <<collection_guard>>
  <<user_interface>>

  from anki import Collection
  from anki.importing import TextImporter
  from anki.tags import TagManager

  def constag(deckname):
      return "fordeck%s" % deckname

  # get foreign notes: these aren't (yet) real Anki notes, just a
  # represenation that has been read in.
  def getfnotes(ti):
      # now, get the notes
      fnotes = ti.foreignNotes();
      return fnotes;

  def addtag(ti, fnotes, tag):
      for i, fn in enumerate(fnotes):
          fn.tags.append(tag)

  def add2col(col, deckname, ti, fnotes):
      # XXX should we remember previously selected deck (and reselect it
      # when we're done here)?
      did = col.decks.id(deckname)
      if did != ti.model['did']:
          ti.model['did'] = did
          col.models.save(ti.model)
      col.decks.select(did)
      ti.importNotes(fnotes)

  # http://ankisrs.net/docs/addons.html#the-database
  def run(ankipath, deckname):
      tag = constag(deckname);    # just run once!
      with collection_guard(ankipath) as cg:
          col = cg.col
          ti = TextImporter(col, imfile)
          ti.initMapping();
          if showMapping(ti):     # allow user to abort
              # first, get anki read in the notes (to an intermediate form)
              fnotes = getfnotes(ti)
              # next, add our tag to the notes
              addtag(ti, fnotes, tag)
              # now, add these notes to the designated deck
              add2col(col, deckname, ti, fnotes)
              if ti.log:
                  for txt in ti.log:
                      print txt
              imported = ti._ids      # cards that were imported
              del ti;                 # no longer to be used
              # now, move any notes from any *other* cards with this tag to this deck
              did = col.decks.id(deckname)
              col.decks.setDeck(imported, did)
              # now, delete any notes in deck that do *not* have this tag
              xxx()
              # now, delete this tag from these cards (no other cards should have this tag)
              # done!
#+END_SRC

#+RESULTS: import
: None

#+BEGIN_SRC python :session ps :results output :var ankipath=anki2 :var deckname=deckname :var imfile=imfile :noweb yes
  <<import>>

  import pdb
  #  pdb.run('run(ankipath, deckname)')
  run(ankipath, deckname)
#+END_SRC

#+RESULTS:
#+begin_example
#+end_example

