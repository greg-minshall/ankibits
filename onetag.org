* ONETAG: (anki menu item)

** what we want to do

it turns out that Anki opens files in a way that won't allow a
pipeline (as far as i can see), so the file itself needs to have the
tags in it.  or, maybe /dev/fdN could be used?

want a function that, given an argument, will ensure that 1) the
current deck has only cards with TAG; 2) all cards in Anki with TAG
are in that deck.

so, first, find all cards *not* in the current deck with TAG.  then,
move all those cards from their previous deck to the current deck.

XXX should we check we're not moving *too* many cards?

then, search the current deck and find all cards that do *not* have
the the designated tag.  delete all those cards.

XXX same, should we check we're not deleting too many cards?

remove the menu item (or, at least, the pre-canned tag)

after all this, *delete* the tags from all cards in the current
deck.

ANKI-IMPORT: (shell command)
usage: run the import operation, which cons up TAG, and adds it to
all the cards in the deck, then imports the cards into the named
deck: ./anki-import turkish-2015 turkish-2015.html after the import,
prime a menu item in Anki (with a shortcut, hopefully), that will
cause onetag to run with the correct tag.

one function: given a file name and a deck name, import the contents
of that file into that deck.  need to have it tell how many fields
it will find (maybe separate function for that?).

one function: given a search expression (such as "deck:current
tag:fubar"), execute the search, and then execute a "move" to a
designated deck (which must already exist).

one function: given a search expression, execute the search and
print out the resulting cards.

one function: print the names of the existing decks.

one function: remove a given tag from a given (all?) deck(s?).

to get anki to work, need to run ./tools/build-ui.sh.  for *that*,
needed something from Qt designer, which required installing a bunch
of Qt.  then, to actually run it, needed to extend path, which i did
by
#+BEGIN_EXAMPLE
bash
PATH=/sw/lib/qt4-mac/lib/python2.7/bin/:$PATH
./tools/build_ui.sh 
#+END_EXAMPLE
then, needed to copy all the files to ~/usr/lib/python/anki/ again
(i.e., *after* running ./tools/build-ui.sh).

cool.  now have an x11 version of anki ("% ./runanki").

** some code
#+name: anki2
| /Users/minshall/Documents/Anki/test/collection.anki2 |
#+name: deck
| testdeck |
#+name: imfile
| /Users/minshall/src/mine/ankiplugins/test.html |


#+BEGIN_SRC python :var a=deck[0,0] :results results raw :session ss
#+END_SRC

#+RESULTS:
testdeck

this allows us to open an Anki collection and ensure that the
collection is closed "no matter what" happens.  (this does *not*
include some extraordinary event, such as a core dump.)  this comes
from http://effbot.org/zone/python-with-statement.htm

#+name: collection_guard
#+BEGIN_SRC python :session ss :results silent
  class collection_guard:
      def __init__(self, ankipath):
          self.ankipath = ankipath;
      def __enter__(self):
          self.col = Collection(ankipath);
          return self;
      def __exit__(self, type, value, traceback):
          if self.col is not None:
              self.col.close();
              self.col = None
          return False
      def abort(self):            # we're unhappy, so *don't* close
          if self.col is not None:
              self.col = None
      def close(self):
          self.__exit__(None, None, None)
#+END_SRC

#+name: decks
#+BEGIN_SRC python :var ankipath=anki2[0,0] :results output :session ss
  from anki import Collection

  def pdecks(col):
      for i, val in enumerate(col.decks.allNames()):
          print val

  def pdecksrun():
      with collection_guard(ankipath) as cg:
          pdecks(cg.col)

  pdecksrun();
#+END_SRC

#+RESULTS: decks
: 
: >>> ... ... ... >>> ... ... ... >>> Default
: testdeck
: decktest

#+name: notes
#+BEGIN_SRC python :results output :var ankipath=anki2[0,0] deckname=deck[0,0] :session ss
  from anki import Collection

  def pnotes(col, deckname):
      ids = col.findNotes("deck:%s" % deckname)
      print ids;
      for i, id in enumerate(ids):
          note = col.getNote(id)
          values = note.values();
          print "%s\t%s" % (values[0], values[1])

  def pnotesrun(ankipath, deckname):
      with collection_guard(ankipath) as cg:
          pnotes(cg.col, deckname)

  pnotesrun(ankipath, deckname);
#+END_SRC

#+RESULTS: notes
: 
: >>> >>> >>> ... ... ... ... ... ... ... >>> ... ... ... >>> []

#+name: tags
#+BEGIN_SRC python :results output :var anki=anki2[0,0] deckname=deck[0,0] :session ss
  from anki import Collection
  with collection_guard(ankipath) as cg:
      ids = cg.col.findCards("deck:%s" % deckname)
#+END_SRC

#+RESULTS: tags

#+name: import
#+BEGIN_SRC python :session ss :results output :var ankipath=anki2[0,0] :var deckname=deck[0,0] :var imfile=imfile[0,0]
  from anki import Collection
  from anki.importing import TextImporter
  from anki.tags import TagManager

  def constag():
      import time;
      return "asof%d" % time.time();

  # get foreign notes: these aren't (yet) real Anki notes, just a
  # represenation that has been read in.
  def getfnotes(ti):
      # now, get the notes
      fnotes = ti.foreignNotes();
      return fnotes;

  def addtag(ti, fnotes, tag):
      for i, fn in enumerate(fnotes):
          fn.tags.append(tag)

  def add2col(col, deckname, ti, fnotes):
      # XXX should we remember previously selected deck (and reselect it
      # when we're done here)?
      did = col.decks.id(deckname)
      col.decks.select(did)
      ti.importNotes(fnotes)

  # http://ankisrs.net/docs/addons.html#the-database
  def run(ankipath, deckname):
      tag = constag();            # just run once!
      with collection_guard(ankipath) as cg:
          col = cg.col
          ti = TextImporter(col, imfile)
          ti.initMapping();
          # first, get anki read in the notes (to an intermediate form)
          fnotes = getfnotes(ti)
          # next, add our tag to the notes
          addtag(ti, fnotes, tag)
          # now, add these notes to the designated deck
          add2col(col, deckname, ti, fnotes)
          del ti;                 # no longer to be used
          # now, delete any notes in deck that do *not* have this tag
          delnontagged(col, tag, deckname)
          # now, move any notes from any *other* cards with this tag to this deck
          movetagged(col, tag, deckname)
          # now, delete this tag from these cards (no other cards should have this tag)
          # done!

  run(ankipath, deckname)
#+END_SRC

#+RESULTS: import
: 
: >>> >>> >>> >>> >>> >>> ... ... ... >>> ... ... ... ... ... ... >>> ... ... ... >>> ... ... ... ... ... ... >>> ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... >>> Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 16, in run
: NameError: global name 'delnontagged' is not defined




** some bugs maybe in dae's code/documentation

*** [[http://ankisrs.net/docs/addons.html][add-on documentation]] bugs

+ in "Import a text file into the collection", should
#+BEGIN_QUOTE
deck['mid'] = m['id']
#+END_QUOTE
possibly be
#+BEGIN_QUOTE
deck['mod'] = m['mod']
#+END_QUOTE
?

+ also, i run this code, and my cards get added to the "Default" deck
  (rather than to the one i looked up using col.decks.id).  here's
  (more or less) DAE's example:
#+BEGIN_SRC python :session that
  from anki import Collection
  from anki.importing import TextImporter
  file = u"/Users/minshall/src/mine/ankiplugins/test.html"
  # select deck
  col = Collection("/Users/minshall/Documents/Anki/test/collection.anki2");
  did = col.decks.id("decktest")
  col.decks.select(did)
  # set note type for deck
  m = col.models.byName("Basic")
  deck = col.decks.get(did)
  deck['mid'] = m['id']
  col.decks.save(deck)
  # import into the collection
  ti = TextImporter(col, file)
  ti.initMapping()
  ti.run()
#+END_SRC


